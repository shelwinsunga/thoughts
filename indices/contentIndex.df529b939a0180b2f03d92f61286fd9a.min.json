{"/":{"title":"Notes","content":"\nA catalog of notes, thoughts, and other digital type that I have created or consumed.\n\n### [MIT 6.824: Distributed Systems](tags/6.824)\n\n\n","lastmodified":"2022-11-09T23:08:13.8174105Z","tags":null},"/comp/cowsignal":{"title":"Cow Signal","content":"\nUSACO 2016 December Contest, Bronze - Problem 3. The Cow-Signal\n# Problem Statement\n\nBessie and her cow friends are playing as their favorite cow superheroes. Of course, everyone knows that any self-respecting superhero needs a signal to call them to action. Bessie has drawn a special signal on a sheet of $M×N$ paper $(1≤M≤10,1≤N≤10)$, but this is too small, much too small! Bessie wants to amplify the signal so it is exactly $K$ times bigger $(1≤K≤10)$ in each direction.\n\n#### Input Format (cowsignal.in)\n\nThe first line of input contains $M$,$N$, and $K$, separated by spaces.\nThe next $M$ lines each contain a length-$N$ string, collectively describing the picture of the signal.\n\n#### Output Format (cowsignal.out)\n\nYou should output $KM$ lines, each with $KN$ characters, giving a picture of the enlarged signal.\n\n\n#### Sample Input: \n5 4 2   \u003cbr\u003e\nXXX.    \u003cbr\u003e\nX..X    \u003cbr\u003e\nXXX.    \u003cbr\u003e\nX..X    \u003cbr\u003e\nXXX.    \u003cbr\u003e\n#### Sample Output:\n\nXXXXXX..    \u003cbr\u003e\nXXXXXX..    \u003cbr\u003e\nXX....XX    \u003cbr\u003e\nXX....XX    \u003cbr\u003e\nXXXXXX..    \u003cbr\u003e\nXXXXXX..    \u003cbr\u003e\nXX....XX    \u003cbr\u003e\nXX....XX    \u003cbr\u003e\nXXXXXX..    \u003cbr\u003e\nXXXXXX..    \u003cbr\u003e\n\n# My Solution\n\u003cbr\u003e\n\n```\n#include \u003ciostream\u003e\n#include \u003cvector\u003e\n#include \u003cstring\u003e\nusing namespace std;\n\nint main()\n{\n    freopen(\"cowsignal.in\", \"r\", stdin);\n\tfreopen(\"cowsignal.out\", \"w\", stdout);\n    int m,n,k;\n    scanf(\"%d %d %d\", \u0026m, \u0026n, \u0026k);\n    string s; \n    vector\u003cstring\u003e signal;\n    for(int i = 0; i \u003c m; i++){\n        cin \u003e\u003e s;\n        string newSignal = \"\";\n\n        for(int j = 0; j \u003c n; j++){\n            for(int x = 0; x \u003c k; x++){\n                newSignal.push_back(s[j]);\n            }\n        }\n        for(int y = 0; y \u003c k; y++){\n            signal.push_back(newSignal);\n        }\n    }\n    for(string s: signal){\n        cout \u003c\u003c s \u003c\u003c endl;\n    }\n    return 0;\n}\n\n```\n","lastmodified":"2022-11-09T23:08:13.8174105Z","tags":null},"/comp/lostcow":{"title":"The Lost Cow","content":"\n\nUSACO 2017 US Open Contest, Bronze - Problem 1. The Lost Cow\n# Problem Statement\n\nFarmer John has lost his prize cow Bessie, and he needs to find her!\nFortunately, there is only one long path running across the farm, and Farmer John knows that Bessie has to be at some location on this path. If we think of the path as a number line, then Farmer John is currently at position $x$ and Bessie is currently at position $y$ (unknown to Farmer John). If Farmer John only knew where Bessie was located, he could walk directly to her, traveling a distance of $|x−y|$. Unfortunately, it is dark outside and Farmer John can't see anything. The only way he can find Bessie is to walk back and forth until he eventually reaches her position.\n\nTrying to figure out the best strategy for walking back and forth in his search, Farmer John consults the computer science research literature and is somewhat amused to find that this exact problem has not only been studied by computer scientists in the past, but that it is actually called the \"Lost Cow Problem\" (this is actually true!).\n\nThe recommended solution for Farmer John to find Bessie is to move to position $x+1$, then reverse direction and move to position $x−2$, then to position $x+4$, and so on, in a \"zig zag\" pattern, each step moving twice as far from his initial starting position as before. As he has read during his study of algorithms for solving the lost cow problem, this approach guarantees that he will at worst travel 9 times the direct distance $|x−y|$ between himself and Bessie before he finds her (this is also true, and the factor of 9 is actually the smallest such worst case guarantee any strategy can achieve).\n\nFarmer John is curious to verify this result. Given $x$ and $y$, please compute the total distance he will travel according to the zig-zag search strategy above until he finds Bessie.\n\n#### Input Format (cowsignal.in)\n\nThe single line of input contains two distinct space-separated integers $x$ and $y$. Both are in the range $0 \\ldots 1,000$.\n\n#### Output Format (cowsignal.out)\n\nPrint one line of output, containing the distance Farmer John will travel to reach Bessie.\n\n\n\n#### Sample Input: \n3 6\n#### Sample Output:\n\n9\n\n# My Solution\n\u003cbr\u003e\n\n```\n#include \u003ciostream\u003e\n#include \u003cvector\u003e\nusing namespace std;\n\nint main() {\n  freopen(\"lostcow.in\", \"r\", stdin);\n  freopen(\"lostcow.out\", \"w\", stdout);\n\n  int x, y;\n  scanf(\"%d %d\", \u0026x, \u0026y);\n  int origin = x;\n\n  int d = 0;\n  int k = 1;\n\n  // approach:\n  int turn = 1;\n  while (x != y) {\n    if (turn % 2 != 0) {\n      for (int i = 1; i \u003c= k; i++) {\n        if (x == y)\n          break;\n        x++;\n        d++;\n      }\n\n      for (int i = 1; i \u003c= k; i++) {\n        if (x == y)\n          break;\n        x--;\n        d++;\n      }\n\n    } else {\n      for (int i = 1; i \u003c= k; i++) {\n        if (x == y)\n          break;\n        x--;\n        d++;\n      }\n\n      for (int i = 1; i \u003c= k; i++) {\n        if (x == y)\n          break;\n        x++;\n        d++;\n      }\n    }\n    k *= 2;\n    turn++;\n  }\n\n  cout \u003c\u003c d \u003c\u003c endl;\n  return 0;\n}\n\n```\n","lastmodified":"2022-11-09T23:08:13.8174105Z","tags":null},"/notes/6.824/DistributedSystemsIntro":{"title":"Introduction to Distributed Systems","content":"\nThe core of a **distributed system** is a set of cooperating computers that are communicating with each other over a network to get some coherent task done. Examples are storage, big data computations, and peer-to-peer file sharing. A lot of critical infrastructure out there is built by distributed systems. If you're designing a system, if you can possibly solve it with a single computer, do that. It's **always** easier that way. Try everything else before a distributed system, because they're not simpler.\n\n## Reasons we use distributed systems\n1. Performance: How do I get 1000 computers to give me 1000x the compute?\n    - The reason people use lots of cooperating computers is because they need high-performance, and to accomplish that they need parallelism. \n2. Fault Tolerance\n    - Have two computers do the exact same thing, if one fails give the task to the other one.\n3. Physical\n    - Some problems are naturally spread out into space and become inherently physically distributed systems.\n    - Two Banks across the country dealing with the transfer of money.\n4. Security \n    - Improve security by splitting things between multiple computers, resulting in isolation.\n\n\n\n## Basic Challenges\n\n##### Concurrency \n\nBecause distributed systems compute concurrently, you get all the problems that come up with concurrent programming. Complex interactions and weird timing dependant stuff make the world a scary place.\n\n##### Partial Failure\n\nDistributed is hard because with all the different computers in addition to a network, you will have unexpected failure patterns. If you were working with a single computer, it's usually the case that the computer is working, or it's not. A distributed system may have multiple computers not working, or a single computer not working. A part of the network might be down. These result in partial failures.\n\n##### Performance\n\nThough we build computers to obtain high-performance, there's a lot of roadblocks in the way. It takes careful design to get the performance you feel you deserve.\n\n\n\n\n\n\n\n\n","lastmodified":"2022-11-09T23:08:13.8174105Z","tags":null},"/notes/6.824/FaultTolerance":{"title":"Fault Tolerance","content":"\nSee Also: [Scalability](Scalability.md), [Infrastructure for Applications](Infrastructure%20for%20Applications.md), and [Introduction to Distributed Systems](DistributedSystemsIntro.md)\n\nA single computer can often stay up for years. However, if you're building a system with thousands of computers, that means you're going to have about 3 computer failiures per day. Big problems with big distributed systems turn rare failiure problems to failiure problems that happen all the time. There's almost always something broken: a computer crashed, a piece of the network is down, someone stepped over a cable, a fan is overheating - something always goes wrong. \n\n# Designing around Fault Tolerance\n\nThis means that when you're designing a distributed system, you have to bake in the masking or invisibility of these constant failiures. This makes the programmer's life easier. \n\nSome systems are designed to continue providing, despite partial failiures, undamaged service. These systems are called **available**. The way available systems are specified is that they will stop working after a certain amount of partial failiure.\n\nOther systems will stop working when there are failiures and wait for the failed components to be repaired. But when it does recover, when those components are fixed, the system will continue providing service as if nothing ever went wrong. Systems like these need to do things like save their data on disc. Note available systems can also be recoverable.\n\n## Storage\n\nNon-volatile storage is a good way to keep track of the state of the system. These tend to be expensive to update. \n\nAnother tool is replication. The problem is that the two replicas tend to drift out of sync and stop becoming replicas. \n","lastmodified":"2022-11-09T23:08:13.8174105Z","tags":null},"/notes/6.824/Infrastructure-for-Applications":{"title":"Infrastructure for Applications","content":"\nSee also: [Introduction to Distributed Systems](DistributedSystemsIntro.md)\n\nA lot of our goal is to discover **abstractions**, or ways of simplifying the interface of distributed storage and infrastructure so that it is easy to build applications on top of it. We want to *hide* the fact the system is distributed.\n\n# Implementation \n\n1. Remote Procedure Call (RPC)\n    - Mask the fact you're communicating over an unreliable network.\n\n2. Threads\n    - A way of structuring concurrent operations so that the programmer lives a happier life.\n\n3. Concurrency control\n    - We'll need to spend a certain amount of time thinking about this.\n\n\n\n\n\n\n\n\n\n\n\n\n","lastmodified":"2022-11-09T23:08:13.8174105Z","tags":null},"/notes/6.824/Scalability":{"title":"System Scalability","content":"\nUsually the high-level goal of building a distributed system is to build something with scalable speed-up. It's the idea that with 2 times the computer resources, I should get 2 times the throughput. The alternative is to pay programmers to restructure your software. To get more performance, you can either buy more compute, or better programmers. Compute is cheaper, so more ideal.\n\n## Got a website?\n\nWhen you host a website, it runs on a web server and has a database attached to it. To add more compute so that more users can visit your website, you add more web servers. This kind of scalability is rarely infinite, and as you add more web servers, suddenly the database has too much pressure. ","lastmodified":"2022-11-09T23:08:13.8174105Z","tags":null},"/notes/life/minimal":{"title":"Minimalistic Workout","content":"\n# Full Body Day 1\n\nWarm up: Brisk Walking and Dynamic Stretches\n\n1. Flat Dumbbell Press: 1x4-6 reps heavy 1x 8-10 reps backoff weight\n2. Dumbbell Romanian Deadlift: 3x8-10\n3. 2-grip Lat Pulldown: 2x10-12 reps\n4. Dumbbell Step Up: 1x8-10\n5. Overheap Cable Triceps Extension 1x12-15 reps + Dropset\n6. Machine Lateral Raise: 1x12-15 reps\n7. Leg press toe raise 1x12-15 reps\n\n\n# Full Body Day 2\n\nWarm up: Brisk Walking and Dynamic Stretches\n\n1. Hack Squat: 1x4-6 reps + 1x8-10 reps\n2. Antagonistic Superset\n    - T-bar row: 2x10-12\n    -  High Incline Smith Press: 2x10-12\n3. Replace with dumbbell\n4. Seated Leg Curl: 1x10-12\n5. EZ-Bar Bicep Curl: 1x12-15\n6. Cable Crunch: 1x12-15\n\n\n\n","lastmodified":"2022-11-09T23:08:13.8174105Z","tags":null}}