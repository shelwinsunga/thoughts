<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Software on</title><link>https://shelwinsunga.github.io/thoughts/tags/Software/</link><description>Recent content in Software on</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 28 Apr 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://shelwinsunga.github.io/thoughts/tags/Software/index.xml" rel="self" type="application/rss+xml"/><item><title>Merge Sort</title><link>https://shelwinsunga.github.io/thoughts/notes/mergeSort/</link><pubDate>Fri, 28 Apr 2023 00:00:00 +0000</pubDate><guid>https://shelwinsunga.github.io/thoughts/notes/mergeSort/</guid><description>Merge Sort You probably know about naive sorting methods: selection sort, insertion sort, bubble sort, etc. These are all $O(n^2)$ algorithms, which is quite bad.</description></item><item><title>Introduction to Databases</title><link>https://shelwinsunga.github.io/thoughts/notes/ds/introdb/</link><pubDate>Tue, 14 Feb 2023 00:00:00 +0000</pubDate><guid>https://shelwinsunga.github.io/thoughts/notes/ds/introdb/</guid><description>The simplest database we can have is a bunch of CSV files that we can manage with our own code. For every entity, we&amp;rsquo;ll store them in our own file (album.</description></item><item><title>Load Balancing</title><link>https://shelwinsunga.github.io/thoughts/notes/scalability/scalability/</link><pubDate>Tue, 03 Jan 2023 00:00:00 +0000</pubDate><guid>https://shelwinsunga.github.io/thoughts/notes/scalability/scalability/</guid><description>Scalability When we deploy a website, we need to put it on a server. Users will send requests to the server, and the server will respond.</description></item><item><title>BFS and Graph Algorithm Implementations</title><link>https://shelwinsunga.github.io/thoughts/notes/data-structures/BFS-Graph/</link><pubDate>Sat, 31 Dec 2022 00:00:00 +0000</pubDate><guid>https://shelwinsunga.github.io/thoughts/notes/data-structures/BFS-Graph/</guid><description>So far, we have seen a few graph traversals;
DFS Preorder: returns in order of dfs calls DFS Postorder: returns in order of dfs returns BFS order: returns in order of distance from source BFS order is analogous to level order traversal.</description></item><item><title>Graph Problems</title><link>https://shelwinsunga.github.io/thoughts/notes/data-structures/graph-problems/</link><pubDate>Sat, 31 Dec 2022 00:00:00 +0000</pubDate><guid>https://shelwinsunga.github.io/thoughts/notes/data-structures/graph-problems/</guid><description>Graph Queries There are a lot of interesting questions we can ask about a graph. What is the shortest path between two points?</description></item><item><title>Graphs</title><link>https://shelwinsunga.github.io/thoughts/notes/data-structures/graph/</link><pubDate>Sat, 31 Dec 2022 00:00:00 +0000</pubDate><guid>https://shelwinsunga.github.io/thoughts/notes/data-structures/graph/</guid><description>Trees are fantastic for representing strict hierarchial relationships.
But not every relationship is hierarchial. A graph consists of:</description></item><item><title>Heaps</title><link>https://shelwinsunga.github.io/thoughts/notes/data-structures/heap/</link><pubDate>Sat, 31 Dec 2022 00:00:00 +0000</pubDate><guid>https://shelwinsunga.github.io/thoughts/notes/data-structures/heap/</guid><description>Heaps are a pretty famous data structure. Note that they&amp;rsquo;re not at all related to &amp;rsquo;the heap&amp;rsquo;, something you&amp;rsquo;d learn in an operating systems class.</description></item><item><title>Priority Queue</title><link>https://shelwinsunga.github.io/thoughts/notes/data-structures/pq/</link><pubDate>Sat, 31 Dec 2022 00:00:00 +0000</pubDate><guid>https://shelwinsunga.github.io/thoughts/notes/data-structures/pq/</guid><description>A priority queue allows tracking and removal of the smallest item.
the interface;
add getSmallest removeSmallest It can transform a problem which requires a lot of memory into one which requires much less.</description></item><item><title>Tree Traversals</title><link>https://shelwinsunga.github.io/thoughts/notes/data-structures/tree-traversal/</link><pubDate>Sat, 31 Dec 2022 00:00:00 +0000</pubDate><guid>https://shelwinsunga.github.io/thoughts/notes/data-structures/tree-traversal/</guid><description>Unlike a linked list, where you can traverse the list by following the next pointers, a tree is a bit more complicated.</description></item><item><title>Tree vs Graph Traversals</title><link>https://shelwinsunga.github.io/thoughts/notes/data-structures/tree-vs-graph/</link><pubDate>Sat, 31 Dec 2022 00:00:00 +0000</pubDate><guid>https://shelwinsunga.github.io/thoughts/notes/data-structures/tree-vs-graph/</guid><description>Just as there are many tree traversals:
Preorder Inorder Postorder Level Order DFS Preorder What we did in DepthFirstPaths is called &amp;ldquo;DFS Preorder&amp;rdquo;: Action is before DFS.</description></item><item><title>B-Tree Analysis</title><link>https://shelwinsunga.github.io/thoughts/notes/data-structures/btreeinvariant/</link><pubDate>Fri, 30 Dec 2022 00:00:00 +0000</pubDate><guid>https://shelwinsunga.github.io/thoughts/notes/data-structures/btreeinvariant/</guid><description>Bushiness and Invariants Unlike in BSTs, where if you insert things in order the tree will be spindly, in B-Trees, if you insert things in order, the tree will be bushy no matter what.</description></item><item><title>Hash Performance</title><link>https://shelwinsunga.github.io/thoughts/notes/data-structures/hash/hash-performance/</link><pubDate>Fri, 30 Dec 2022 00:00:00 +0000</pubDate><guid>https://shelwinsunga.github.io/thoughts/notes/data-structures/hash/hash-performance/</guid><description>Unfortunately, the hash table we devised is $O(Q)$ for its operations, and $Q$ has $O(N)$ order of growth.
This is really bad, because eventually our operations will get slow.</description></item><item><title>Red Black Trees Definition</title><link>https://shelwinsunga.github.io/thoughts/notes/data-structures/red-black-tree-def/</link><pubDate>Fri, 30 Dec 2022 00:00:00 +0000</pubDate><guid>https://shelwinsunga.github.io/thoughts/notes/data-structures/red-black-tree-def/</guid><description>Red Black Trees are trees that are structurally indentical to B-Trees, but have glue links. This idea is commonly used in practice (ex: java.</description></item><item><title>Red Black Trees Intro</title><link>https://shelwinsunga.github.io/thoughts/notes/data-structures/red-black-tree/</link><pubDate>Fri, 30 Dec 2022 00:00:00 +0000</pubDate><guid>https://shelwinsunga.github.io/thoughts/notes/data-structures/red-black-tree/</guid><description>&amp;ldquo;Beautiful algorithms are, unfortunately, not always the most useful.&amp;rdquo; - Donald Knuth
B-Trees are painful to implement. And even if you do implement them, they&amp;rsquo;re still not that great.</description></item><item><title>Red Black Trees Performance</title><link>https://shelwinsunga.github.io/thoughts/notes/data-structures/redblacksummary/</link><pubDate>Fri, 30 Dec 2022 00:00:00 +0000</pubDate><guid>https://shelwinsunga.github.io/thoughts/notes/data-structures/redblacksummary/</guid><description>LLRB Runtime LLRB has height $O(log(n))$ Contains is trivially $O(log(n))$ Insert is $O(log(n))$ $O(log(n))$ to add new node $O(log(n))$ to fix up tree (rotation and color flips) We won&amp;rsquo;t discuss delete because it&amp;rsquo;s uninteresting.</description></item><item><title>Red Black Trees Rules</title><link>https://shelwinsunga.github.io/thoughts/notes/data-structures/rrbinsert/</link><pubDate>Fri, 30 Dec 2022 00:00:00 +0000</pubDate><guid>https://shelwinsunga.github.io/thoughts/notes/data-structures/rrbinsert/</guid><description>Red Black Tree Rules When inserting: use a red link
If there is a right leaning &amp;ldquo;3-node&amp;rdquo;, we have a left leaning violation.</description></item><item><title>S-T Connectivity</title><link>https://shelwinsunga.github.io/thoughts/notes/data-structures/s-t/</link><pubDate>Fri, 30 Dec 2022 00:00:00 +0000</pubDate><guid>https://shelwinsunga.github.io/thoughts/notes/data-structures/s-t/</guid><description>See Also: Graph Problems
Let&amp;rsquo;s solve a classic graph problem called s-t connectivity problem.
Given source vertex $s$ and a target vertex $t$, is there a path from $s$ to $t$?</description></item><item><title>B-Tree</title><link>https://shelwinsunga.github.io/thoughts/notes/data-structures/Btree/</link><pubDate>Wed, 28 Dec 2022 00:00:00 +0000</pubDate><guid>https://shelwinsunga.github.io/thoughts/notes/data-structures/Btree/</guid><description>B-Trees are a kind of self-balancing BST.
B-Trees To start, let&amp;rsquo;s make a rule to never add a new leaf. Instead, we&amp;rsquo;ll just add any new value to a node.</description></item><item><title>Abstract Data Types</title><link>https://shelwinsunga.github.io/thoughts/notes/data-structures/ADT/</link><pubDate>Tue, 27 Dec 2022 00:00:00 +0000</pubDate><guid>https://shelwinsunga.github.io/thoughts/notes/data-structures/ADT/</guid><description>Abstract Data types are defined by their operations, not their implementation.
The Stack ADT The Stack ADT supports the following operations:</description></item><item><title>BST Operations</title><link>https://shelwinsunga.github.io/thoughts/notes/data-structures/bstoperations/</link><pubDate>Tue, 27 Dec 2022 00:00:00 +0000</pubDate><guid>https://shelwinsunga.github.io/thoughts/notes/data-structures/bstoperations/</guid><description>Search If searchKey = T.key, return.
If searchKey &amp;lt; T.key, search T.left; If searchKey &amp;gt; T.key, search T.right; Runtime to complete search on a bushy BST in the worst case is $O(log(n))$.</description></item><item><title>BST Performance</title><link>https://shelwinsunga.github.io/thoughts/notes/data-structures/BStperformance/</link><pubDate>Tue, 27 Dec 2022 00:00:00 +0000</pubDate><guid>https://shelwinsunga.github.io/thoughts/notes/data-structures/BStperformance/</guid><description>Height and average depth are important properties of BSTs:
The depth of a node is how far it is from the root The height of a tree is the depth of its deepest leaf The average depth of a tree is the average depth of a tree&amp;rsquo;s nodes.</description></item><item><title>BST Tree Height</title><link>https://shelwinsunga.github.io/thoughts/notes/data-structures/BSTheight/</link><pubDate>Tue, 27 Dec 2022 00:00:00 +0000</pubDate><guid>https://shelwinsunga.github.io/thoughts/notes/data-structures/BSTheight/</guid><description>Height varies dramatically between &amp;ldquo;bushy&amp;rdquo; and &amp;ldquo;spindly&amp;rdquo; trees.
Bushy trees have a height of roughly $log(n)$. Spindly trees have a height of $n$.</description></item><item><title>Hashing Collisions</title><link>https://shelwinsunga.github.io/thoughts/notes/data-structures/hash/hash-collisions/</link><pubDate>Tue, 27 Dec 2022 00:00:00 +0000</pubDate><guid>https://shelwinsunga.github.io/thoughts/notes/data-structures/hash/hash-collisions/</guid><description>Pigeonhole principle tells us that collisions are inevitable due to integer overflow.
hash code for &amp;ldquo;moo&amp;rdquo; and &amp;ldquo;nep&amp;rdquo; might both be 718.</description></item><item><title>Hashing Intro</title><link>https://shelwinsunga.github.io/thoughts/notes/data-structures/hash/hash-intro/</link><pubDate>Tue, 27 Dec 2022 00:00:00 +0000</pubDate><guid>https://shelwinsunga.github.io/thoughts/notes/data-structures/hash/hash-intro/</guid><description>Our search trees have excellent $O(log(n))$ performance. Can we do better? And can we do it without comparisons?
Approach: Taking advantage of arrays The idea is simple: Create a boolean array of $N$ length that is initialized as false.</description></item><item><title>Trees</title><link>https://shelwinsunga.github.io/thoughts/notes/data-structures/trees/</link><pubDate>Sun, 25 Dec 2022 00:00:00 +0000</pubDate><guid>https://shelwinsunga.github.io/thoughts/notes/data-structures/trees/</guid><description>A tree consists of
A set of nodes A set of edges that connect those nodes Constraint: There is exactly one path between any two nodes.</description></item><item><title>A Brief Overview of Netflow</title><link>https://shelwinsunga.github.io/thoughts/thoughts/netflow/</link><pubDate>Wed, 16 Nov 2022 00:00:00 +0000</pubDate><guid>https://shelwinsunga.github.io/thoughts/thoughts/netflow/</guid><description>One of the challenges of managing a network is understanding what&amp;rsquo;s actually going through that network. We have a lot of different protocols buzzing around - HTTPS, SMTP, SFTP, DNS, etc - so how do we answer questions like how much of each protocol is happening?</description></item><item><title>Shortest Paths</title><link>https://shelwinsunga.github.io/thoughts/notes/data-structures/shortest-paths/</link><pubDate>Sat, 01 Jan 2022 00:00:00 +0000</pubDate><guid>https://shelwinsunga.github.io/thoughts/notes/data-structures/shortest-paths/</guid><description>See also: Graph Problems, S-T Connectivity, Tree vs Graph Traversals
Graph Problems Summary Problem Description Efficiency S-T paths Find a path from s to every reachable vertex S-T shortest paths Find a shortest path from s to every reachable vertex Last time, we saw two ways to find paths in a graph: DFS and BFS.</description></item><item><title>Sorting</title><link>https://shelwinsunga.github.io/thoughts/notes/data-structures/sorts/</link><pubDate>Sat, 01 Jan 2022 00:00:00 +0000</pubDate><guid>https://shelwinsunga.github.io/thoughts/notes/data-structures/sorts/</guid><description>Sorting Informally: Given items, put them in order. This is useful because can do things like:
Allow rapid duplicate finding -Enable binary search Convert into various data structures Knuth&amp;rsquo;s Definition An ordering relation &amp;lt; for keys a, b, and c is has the following properties:</description></item></channel></rss>